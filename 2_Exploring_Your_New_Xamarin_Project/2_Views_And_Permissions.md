# Views & Permissions

## OnCreate

In our Activity classes we have a method called **OnCreate**. This method is called when the activity is first created/called. From then on the activity will remain in memory and OnCreate won't be called again in normal circumstances. We put all of the setup logic for our activity in the **OnCreate** method.

## Views

The views are what the user will see - the visual part of the app. The view files are of type **axml**. The "A" stands for Android, since there are really just valid "XML" files. All views should live inside the Layout folder in the Resources folder that is the convention for Android. Here we'll see a default generated view called **activity_main** inside the Resources/Layout folder. When we will create our own views in the next modules, that's going to be the place where we will add these as well. When opening one of these axml files in Visual Studio, the IDE will show a drag-and-drop interface. 

In the left pane, you see the preview of your application and on the right, you can see the XML, the axml file that is, that makes up the screen. By default, it's going to be a blank view so there won't be a lot in there. If you zoom in on the XML code just a little bit more, we'll see indeed that it is plain XML that we'll need to write for the creation of our views. You can choose to edit this XML yourself, or you can use the drag-and-drop functionality of the designer to create your views. In reality, it's going to be often a mix between both, where you drag the controls onto the screen and you make some changes in the XML. 

At the very root you'll see the **LinearLayout** that is the layout manager. It's goal in life is ensuring that all its child controls get laid out correctly on the screen. On the layout, we also add properties to control its behavior such as the layout width and the layout height. Inside the layout we have currently placed a simple button. That now becomes a child control of the layout, and I've also specified some properties on it, including the text to display, the width and the height, and the id, but take a look at the way that the id is getting its value. Looking back at the way that the activity has specified what should be its view, we see that it specifies this value as **Resource/Layout/activity_main**. You can probably see that this is more or less reflected in the folder structure that this view can be found in. How is the link created? 

There is a little bit of magic going on here through a file called **Resource.Designer.cs**. When you compile your application, this file is being generated or updated to reflect all resources found inside the resources folder. All resources in there will get a value, and indeed your value assigned by the compiler that's a unique value per item inside the Resources folder, and it is the way that Android will be looking for the item you want to use. So for the view located in the subfolder layout, an integer value is generated inside a class called Layout, which is in turn an internal class to the Resource class, and that's the way we can address our view from the activity. It's the way that Android works, and therefore this is also used in Xamarin.Android, but it doesn't stop there. Really all resources within the Resources folder will get a resource value assigned to them. All controls are used inside the views, for example, will also get a value. 

Remember, we used that special to indicate the id for the button in our view. That's used to assign a value within the inner id class. The XML doesn't know about the activity really, so it's inside an activity that we will need to search for our control. We don't directly use the name inside of the code. Instead we use a method called FindViewById, and we pass it the Resource value of the control we want. That is here **Resource.Id.MyButton**. I think this is a bit different compared to regular Windows development. Once we have that reference in the control code, so the button in this case, we can work with it in a regular way. So we can for example attach a click event handler. 

Do you remember these **mipmap** folders that were created by Visual Studio by default? Well, those are there for you to place your graphical assets in. So your application icon will go in there; that's the convention. Same thing if you want to add for example, a splash screen for your application. That too will go in there. Now you may be wondering, why so many of these folders? They seem to differ only in the last part of the name. Android uses a concept of qualifiers. That last part is the qualifier. It points to a resolution so it's your job as an Android developer to add different resolutions of the graphical assets, each in the correct folder. 

Now when your application is running, Android will determine the resolution the device is running with, and it will try to match this with the asset that you have given for the given resolution. Next, there's also the **Drawable** folder. That will typically be the place where you put all your graphical assets in. There too you can use different versions, again using a qualifier. Since all of these are living inside of the Resources folder, when compiling, these assets will also get listed in the **Resource.designer.cs** file and will thus get a resource value, and using that value, we can access the resource just like with view files.

## Permissions

Each Android and therefore also each Xamarin.Android application will contain a **manifest** file. That's a file that can be considered the manual for the application. It lists out all that application contains. So all activities that your application will contain will be listed. All images will get listed, too. It also contains application information such as the application name and the versions. It's used by Android to get to know your application really. It also contains a list of app permissions that your application uses. So what are these application permissions then? 

Your application is running on a user's device, and that can do a lot of things. Making phone calls, getting access to sensors, read contact information, and much, much more. Your application can access most of these, but it can't *without the user's consent*. If your application wants to perform a certain action, it will need to declare this. This way, Android can check if you have honestly listed out everything your application wants to do. This information is all summarized in the application manifest, and it is used by Google Play also to show what the application does upon installation. Once the application is running, the user will need to indicate that he or she is okay with giving your application access to the given resources. We'll add these permissions later when we make a phone call or work with maps. It's typical that these things will require a permission to be added.
